# Probe Sample Object-populated Region as Model

# Context

## Probing Process

### 1. Define Grid of Region of Interest and Bin Size in Magnitude Space
The region of interest is defined by `lower_bound_mag` and `upper_bound_mag` in `../model.py`.
The `lower_bound_mag` is an `1D array` indicates the minimal magnitude for region of interest and the `upper_bound_mag` is also an `1D array` indicates the maximal magnitude for region of interest.
The bin size is defined by `binsize_mag` in `../model.py`, which indicates bin size in unit of magnitude.

### 2. Filter Out Bright/Faint Samples
To save computation time, we remove samples that are not in the region of interest.
However, to maximized the usage of samples, the bright/faint boundaries in previous section __should be set to cover all samples__.

### 3. Bin Samples in Grid in Multi-D Magnitude Space
To save computation time, samples are __binned into grids in multi-D magnitude space__ with bin size defined in previous section
The result will be stored as `dict` that has key as `tuple` indicating grid location and value as `2D array` indicating location of samples before binning

### 4. Project Binned Sample Grids Along Faint Direction to Grid[0]=0 Plane
We first project all binned sample grids __along faint direction to the plane where 1st component of grid is 0__ (in this work is J band magnitude = 0 plane).
And then, we group those grids that are along the same probe along faint direction.
Since they have identical SED shapes, after the projection they are already grouped in the grid on the Grid[0]=0 plane.

| ![Cartoon_SED_AND_MMD_diagonal_probe](../figures/Cartoon_SED_AND_MMD_diagonal_probe.png) |
| :--:                                                                                     |
| Green dots within of orange probe are grouped since they have identical SED shape      |

### 5. Find Bright-end/Faint-end Boundary for Each Group of Projected Grids
By directly comparing the original magnitude (magnitude before projection) of grids in group of projected grids, we can find bright-end/faint-end boundary for each projected grid.
After finding all bright-end/faint-end boundary for projected grids, we now have all the bright-end/faint-end boundary for the object samples.

| ![Cartoon_Finding_Boundary](../figures/Cartoon_Finding_Boundary.png) |
| :--:                                                                 |
| Find bright-end/faint-end boundary for individual SED shape          |

## Input
The input object sample catalog should be stored in text file with columns of magnitude in bands (`float`) and separated by space.
If there are bands that do not have detection for some sources, `-999.0` (`float`) must be assigned to that column in advance.

## Output
The probing process is packed to `../run_probe_model.py`.
The outputs of probing process should be stored in `output_dir` defined in `../run_probe_model.py`.
__For each input sample object catalog, you should have four `.npy` outputs__ which needs NumPy `load` function to load them.

###  1. `XXX_binXX_projected_grid.npy`
- Data type: `dict`
    - `key`: projected grid (`1D tuple`)
    - `value`: grid that locates in the projected grid after projection (`1D array`)

### 2. `XXX_binXX_lower_bound.npy`:
- Data type: `dict`
    - `key`: grid location of boundary (`1D tuple`)
    - `value`: locations of samples within this boundary grid (`1D array`)

### 3. `XXX_binXX_upper_bound.npy`:
- Data type: `dict`
    - `key`: grid location of boundary (`1D tuple`)
    - `value`: location of samples within this boundary grid (`1D array`)

### 4. `XXX_filled_bounds_grid.npy`:
- Data type: `2D array`
    - Grid location `(1D array)` that are generated by fulfilling the regions between `lower_bound` and `upper_bound`
